/******************************************************************************
 * \file initialConditionGenerator.cpp
 * 
 * Main program for navier stokes FDM solver.
 * 
 * compile with
 * g++ main.cpp -o simulateNS
*/

#include <iostream>
#include <iomanip> // For std::setw
#include <fstream>
#include <sstream>
#include <string>
#include <map>
#include <vector>
#include <cmath>

// Directory where we will pull data from csv
const std::string directory_name = "vortex";

// Function to read array from the csv files generated by initialConditionGenerator.ipynb
// Function to read a CSV file into a 2D vector
std::vector<std::vector<double>> readCsv(const std::string& filename) {
    std::ifstream file(filename);
    std::string line;
    std::vector<std::vector<double>> matrix;
    bool isOneDimensional = true;

    // First pass: check if the file contains more than one line
    while (std::getline(file, line)) {
        if (!line.empty()) {  // Ensure the line is not empty
            std::vector<double> row;
            std::stringstream ss(line);
            std::string value;

            while (std::getline(ss, value, ',')) {
                row.push_back(std::stod(value));
            }

            matrix.push_back(row);

            // If we've read more than one line, it's not one-dimensional
            if (matrix.size() > 1) {
                isOneDimensional = false;
                break;
            }
        }
    }
    // If the file is one-dimensional, wrap the vector in another vector to maintain consistency
    if (isOneDimensional && !matrix.empty()) {
        std::vector<double> row = matrix[0];
        matrix.clear();  // Clear the existing content
        matrix.push_back(row);  // Push the 1D vector as a single row of the 2D vector
    }
    // If it's not one-dimensional, continue reading the rest of the file
    if (!isOneDimensional) {
        while (std::getline(file, line)) {
            if (!line.empty()) {  // Ensure the line is not empty
                std::vector<double> row;
                std::stringstream ss(line);
                std::string value;
                while (std::getline(ss, value, ',')) {
                    row.push_back(std::stod(value));
                }
                matrix.push_back(row);
            }
        }
    }
    return matrix;
}

// Function to read scalars from a file into a map
std::map<std::string, double> readScalars(const std::string& filename) {
    std::map<std::string, double> scalars;
    std::ifstream file(filename);
    std::string line;

    while (std::getline(file, line)) {
        size_t delimiterPos = line.find('=');
        std::string key = line.substr(0, delimiterPos);
        double value = std::stod(line.substr(delimiterPos + 1));
        scalars[key] = value;
    }

    return scalars;
}

// Function to write vectors to a csv file
void writeToCsv(const std::vector<std::vector<double>>& u, const std::string& filePath) {
    
    std::ofstream file(filePath);

    if (!file.is_open()) {
        std::cerr << "Error opening file for writing: " << filePath << std::endl;
        return;
    }

    for (const auto& row : u) {
        for (size_t i = 0; i < row.size(); ++i) {
            file << row[i];
            if (i < row.size() - 1) {
                file << ",";
            }
        }
        file << "\n";
    }

    file.close();
}


int main() {
    /**************************************************************************
     * STEP 1:
     * Read data from directory into arrays to use in program
     * This uses the 
    **************************************************************************/

    // Read 2D data from CSV files
    auto u = readCsv(directory_name + "/u.csv");
    auto v = readCsv(directory_name + "/v.csv");
    auto p = readCsv(directory_name + "/p.csv");
    auto gx = readCsv(directory_name + "/gx.csv");
    auto gy = readCsv(directory_name + "/gy.csv");

    // Read scalar data from a file
    auto scalars = readScalars(directory_name + "/scalars.dat");

    // Access scalar values
    double rho = scalars["rho"];        double mu = scalars["mu"];
    double xmin = scalars["xmin"];      double ymin = scalars["ymin"];
    double xmax = scalars["xmax"];      double ymax = scalars["ymax"];
    double dx = scalars["dx"];          double dy = scalars["dy"];
    double tmax = scalars["tmax"];      double dt = scalars["dt"];
    int Nx = static_cast<int>(scalars["Nx"]);
    int Ny = static_cast<int>(scalars["Ny"]);
    int NG = static_cast<int>(scalars["NG"]);

    // This is hack-ish, but I'm just trying to get it to work
    // Read x and y as 2d vectors
    auto x_temp = readCsv(directory_name + "/x.csv");
    auto y_temp = readCsv(directory_name + "/y.csv");
    // Cast them into 1d
    std::vector<double> x (Nx + 2*NG);
    std::vector<double> y (Ny + 2*NG);
    for (int i=0; i<Nx + 2*NG; i++) x[i]=x_temp[0][i];
    for (int j=0; j<Ny + 2*NG; j++) y[j]=y_temp[0][j];

    /**************************************************************************
     * STEP 2:
     * Fields have been initialized, so now we get to start the iteration! :(
    **************************************************************************/        
    // Naively, I need to store different terms of the updating scheme in different variables
    double t1, t2, t3, t4, t5;
    double invRe;

    // time - to be iterated
    double t = 0; int ti = 0;

    // Writing the initial conditions so they are all in the same spot
    writeToCsv(u, "output/u" + std::to_string(ti) + ".csv");
    writeToCsv(v, "output/v" + std::to_string(ti) + ".csv");

    while (t <= tmax)
    {   
        std::cout << "Simulating timestep " << ti << " at time " << t << std::endl;
        // First update the boundary conditions to fill in the ghost zones
        // along interior x points
        for (int i=NG; i<Nx+NG; i++){
            // y=0, along interior x points
            for (int j=0; j<NG; j++) u[i][j] = u[i][NG];
            // y=ymax, along interior x points
            for (int j=Ny+NG; j<Ny+2*NG; j++) u[i][j] = u[i][Ny+NG];
        }
        // along all y points - can handle
        for (int j=0; j<Ny+2*NG; j++) {
            for (int i=0; i<NG; i++) u[i][j] = u[NG][j];
            for (int i=Nx+NG; i<Nx+2*NG; i++) u[i][j] = u[Nx+NG][j];
        }
        // Repeating for v
        // along interior x points
        for (int i=NG; i<Nx+NG; i++){
            // y=0, along interior x points
            for (int j=0; j<NG; j++) v[i][j] = v[i][NG];
            // y=ymax, along interior x points
            for (int j=Ny+NG; j<Ny+2*NG; j++) v[i][j] = v[i][Ny+NG];
        }
        // along all y points - can handle
        for (int j=0; j<Ny+2*NG; j++) {
            for (int i=0; i<NG; i++) v[i][j] = v[NG][j];
            for (int i=Nx+NG; i<Nx+2*NG; i++) v[i][j] = v[Nx+NG][j];
        }

        // Actual iteration
        for (int i=NG; i<Nx+NG; i++){
            for (int j=NG; j<Ny+NG; j++){
                // 1/Re - inverse reynolds number
                invRe = mu/(rho*sqrt(u[i][j]*u[i][j] + v[i][j]*v[i][j])*sqrt(dx*dx + dy*dy)) + 0.1;
                if (!isinf(invRe) || invRe > 5000.0) invRe = 5000.0;        // Necessary to ensure finite Re

                std::cout << i << " " << j << " " << invRe << std::endl; 
                // Actual stencil
                // dpdx
                t1 = 1/(12*dx)*(-p[i+2][j] + 8*p[i+1][j] -8*p[i-1][j] + p[i-2][j]);
                // d2udx2
                t2 = 1/(12*dx*dx) * (-u[i-2][j] + 16*u[i-1][j] - 30*u[i][j] + 16*u[i+1][j] - u[i+2][j]);
                // d2udy2
                t3 = 1/(12*dx*dx) * (-u[i][j-2] + 16*u[i][j-1] - 30*u[i][j] + 16*u[i][j+1] - u[i][j+2]);
                // d(u2)dx
                t4 = 1/(12*dx)*(-u[i+2][j]*u[i+2][j] + 8*u[i+1][j]*u[i+1][j] -8*u[i-1][j]*u[i-1][j] + u[i-2][j]*u[i-2][j]);
                // d(uv)dy
                t5 = 1/(12*dy)*(-u[i][j-2]*v[i][j-2] + 8*u[i][j-1]*v[i][j-1] -8*u[i][j+1]*v[i][j+1] + u[i][j+2]*v[i][j+2]);

                // Updating u
                u[i][j] = u[i][j] + dt*(-t1 + invRe*(t2 + t3) - t4 - t5) + gx[i][j];

                // dpdy
                t1 = 1/(12*dx)*(-p[i][j+2] + 8*p[i][j+1] -8*p[i][j-1] + p[i][j-2]);
                // d2vdx2
                t2 = 1/(12*dx*dx) * (-v[i-2][j] + 16*v[i-1][j] - 30*v[i][j] + 16*v[i+1][j] - v[i+2][j]);
                // d2vdy2
                t3 = 1/(12*dx*dx) * (-v[i][j-2] + 16*v[i][j-1] - 30*v[i][j] + 16*v[i][j+1] - v[i][j+2]);
                // d(uv)dx
                t4 = 1/(12*dx)*(-u[i+2][j]*v[i+2][j] + 8*u[i+1][j]*v[i+1][j] -8*u[i-1][j]*v[i-1][j] + u[i-2][j]*v[i-2][j]);
                // d(v2)dy
                t5 = 1/(12*dy)*(-v[i][j-2]*u[i][j-2] + 8*v[i][j-1]*u[i][j-1] -8*v[i][j+1]*u[i][j+1] + v[i][j+2]*u[i][j+2]);

                v[i][j] = v[i][j] + dt*(-t1 + invRe*(t2 + t3) - t4 - t5) + gy[i][j];
            }
        }

    // Update time
    t += dt; ti++;

    // Output to file
    writeToCsv(u, "output/u" + std::to_string(ti) + ".csv");
    writeToCsv(v, "output/v" + std::to_string(ti) + ".csv");
    }

    return 0;
}